<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divisor de Texto Inteligente</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            max-width: 800px;
            width: 100%;
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Sombra mejorada */
        }
        .input-area {
            resize: none;
        }
        /* La clase .result-box se estilizará principalmente con Tailwind para consistencia */
    </style>
</head>
<body>

    <div class="container rounded-2xl shadow-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Divisor de Texto Inteligente</h1>
        <p class="text-center text-gray-600 mb-6">
            Pega tu texto largo aquí. Se dividirá en fragmentos de no más de 124 caracteres, sin cortar palabras.
        </p>

        <textarea
            id="textInput"
            class="input-area w-full p-4 text-gray-800 bg-gray-50 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors mb-4"
            rows="10"
            placeholder="Escribe o pega tu texto aquí..."
        ></textarea>

        <div id="resultsContainer">
            <!-- Los resultados se mostrarán aquí -->
        </div>
    </div>

    <script>
        const textInput = document.getElementById('textInput');
        const resultsContainer = document.getElementById('resultsContainer');
        const MAX_LENGTH = 124;

        // Escucha el evento 'input' para actualizar la división en tiempo real
        textInput.addEventListener('input', () => {
            const text = textInput.value;
            const fragments = splitText(text, MAX_LENGTH);
            displayResults(fragments);
        });

        /**
         * Divide el texto en fragmentos de una longitud máxima sin cortar palabras.
         * @param {string} text - El texto a dividir.
         * @param {number} maxLength - La longitud máxima de cada fragmento.
         * @returns {string[]} Un array de fragmentos de texto.
         */
        function splitText(text, maxLength) {
            // Si el texto es más corto o igual a la longitud máxima, no hay necesidad de dividirlo.
            if (text.length <= maxLength) {
                return [text];
            }

            const fragments = [];
            let remainingText = text.trim();

            // Bucle que continúa mientras haya texto restante por procesar.
            while (remainingText.length > 0) {
                // Si el texto restante es menor o igual a la longitud máxima, lo añadimos como el último fragmento y salimos del bucle.
                if (remainingText.length <= maxLength) {
                    fragments.push(remainingText);
                    remainingText = '';
                    break;
                }

                // Encontramos el último espacio o salto de línea antes del límite de 124 caracteres.
                let splitPoint = remainingText.lastIndexOf(' ', maxLength);
                
                // Si no se encuentra un espacio, buscamos un salto de línea.
                if (splitPoint === -1) {
                    splitPoint = remainingText.lastIndexOf('\n', maxLength);
                }

                // Caso especial: si una palabra es más larga que la longitud máxima, la cortamos en ese punto para evitar un bucle infinito.
                if (splitPoint === -1 || splitPoint === 0) {
                    splitPoint = maxLength;
                }

                // Extraemos el fragmento de texto desde el inicio hasta el punto de división.
                const fragment = remainingText.substring(0, splitPoint).trim();
                fragments.push(fragment);

                // Actualizamos el texto restante para la siguiente iteración.
                remainingText = remainingText.substring(splitPoint).trim();
            }

            return fragments;
        }

        /**
         * Muestra los fragmentos de texto en la interfaz de usuario.
         * @param {string[]} fragments - El array de fragmentos de texto a mostrar.
         */
        function displayResults(fragments) {
            resultsContainer.innerHTML = '';
            // Si el texto de entrada está vacío, no mostramos nada.
            if (fragments.length === 0 || (fragments.length === 1 && fragments[0] === '')) {
                return;
            }

            // Creamos un cuadro para cada fragmento y lo añadimos al contenedor de resultados.
            fragments.forEach((fragment, index) => {
                const fragmentDiv = document.createElement('div');
                // Uso de clases Tailwind para un estilo consistente y transición para el feedback visual
                fragmentDiv.className = 'result-box flex flex-col sm:flex-row justify-between items-start sm:items-center text-gray-800 p-4 rounded-xl mb-3 bg-gray-200 transition-all duration-300 shadow-md';

                // Usamos un contenedor para el texto y la información, y otro para el botón.
                fragmentDiv.innerHTML = `
                    <div class="flex-grow pr-4 mb-3 sm:mb-0">
                        <p class="font-bold mb-1 text-blue-800">Fragmento ${index + 1} (${fragment.length} caracteres)</p>
                        <pre class="whitespace-pre-wrap text-sm">${fragment}</pre>
                    </div>
                    <button class="copy-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 flex items-center justify-center min-w-[120px]">
                        Copiar
                    </button>
                `;
                
                resultsContainer.appendChild(fragmentDiv);
            });
            
            // Agregamos los event listeners a cada botón después de que se han creado.
            document.querySelectorAll('.copy-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    // Obtenemos el texto del fragmento que está en el mismo contenedor que el botón.
                    const fragmentText = event.target.closest('.result-box').querySelector('pre').textContent;
                    copyToClipboard(fragmentText, event.target);
                });
            });
        }

        /**
         * Copia el texto al portapapeles usando el método document.execCommand('copy'), 
         * que es más robusto en entornos de iframe restringidos.
         * @param {string} text - El texto a copiar.
         * @param {HTMLElement} button - El botón que se hizo clic.
         */
        function copyToClipboard(text, button) {
            const tempTextarea = document.createElement('textarea');
            // Posiciona el textarea fuera de la vista para evitar el desplazamiento de la página.
            tempTextarea.style.position = 'fixed';
            tempTextarea.style.top = '0';
            tempTextarea.style.left = '-9999px';
            tempTextarea.value = text;
            
            document.body.appendChild(tempTextarea);
            
            try {
                // Selecciona el texto dentro del textarea temporal.
                tempTextarea.select();
                // Necesario para compatibilidad móvil
                tempTextarea.setSelectionRange(0, 99999); 
                
                // Ejecuta el comando de copia.
                // Esta es la parte que es más fiable en iframes.
                document.execCommand('copy');
                
                // Muestra la retroalimentación.
                showCopyFeedback(button);

            } catch (err) {
                // Si por alguna razón falla incluso execCommand, registramos el error.
                console.error('Error al intentar copiar con execCommand:', err);
            } finally {
                // Elimina el textarea temporal.
                document.body.removeChild(tempTextarea);
            }
        }

        /**
         * Muestra la retroalimentación visual PERMANENTE de la copia.
         * Se aplica un checkmark y se cambia el estilo del botón y del contenedor del fragmento.
         * @param {HTMLElement} button - El botón para mostrar la retroalimentación.
         */
        function showCopyFeedback(button) {
            // 1. Cambio permanente del botón (verde + Checkmark + Texto)
            button.className = 'copy-btn flex items-center bg-green-600 text-white font-bold py-2 px-4 rounded-full transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-green-700 cursor-not-allowed shadow-xl min-w-[120px]';
            button.disabled = true;
            button.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1 -ml-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                Copiado
            `;

            // 2. Añadir indicación visual al contenedor del fragmento
            const fragmentDiv = button.closest('.result-box');
            if (fragmentDiv) {
                // Aplica un anillo verde y un fondo más claro para indicar el estado de copiado
                fragmentDiv.classList.add('ring-4', 'ring-green-400/50', 'bg-green-50', 'scale-[1.01]');
                fragmentDiv.classList.remove('bg-gray-200', 'shadow-md');
            }
        }
    </script>
</body>
</html>
